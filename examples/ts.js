// Generated by CoffeeScript 1.4.0
(function() {
  var Chart, Component, LineRenderer, MultiTimeseries, NumericTimeseries, SeriesRenderer, Timeseries, VisualSeries, log, merge, plotRegistry, renderArea, renderLine, root, util,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  if (typeof exports !== "undefined" && exports !== null) {
    root = global;
  } else {
    root = window;
  }

  log = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return console.log(args);
  };

  merge = function() {
    var k, object, opt, opts, v, _i, _len;
    object = arguments[0], opts = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    for (_i = 0, _len = opts.length; _i < _len; _i++) {
      opt = opts[_i];
      for (k in opt) {
        v = opt[k];
        object[k] = v;
      }
    }
    return object;
  };

  /*
  ts.coffee - version 0.0.1
  
  Copyright 2012 Dan Simpson
  
  MIT License: http://opensource.org/licenses/MIT
  */


  /*
  #
  #
  */


  Timeseries = (function() {

    function Timeseries(data) {
      this.data = data;
    }

    Timeseries.prototype.size = function() {
      return this.data.length;
    };

    Timeseries.prototype.first = function() {
      return this.data[0];
    };

    Timeseries.prototype.last = function() {
      return this.data[this.size() - 1];
    };

    Timeseries.prototype.sample = function(idx) {
      return this.data[idx];
    };

    Timeseries.prototype.time = function(idx) {
      return this.data[idx][0];
    };

    Timeseries.prototype.value = function(idx) {
      return this.data[idx][1];
    };

    Timeseries.prototype.domain = function() {
      return [this.first()[0], this.last()[0]];
    };

    Timeseries.prototype.values = function() {
      var r, t, v, _i, _len, _ref, _ref1;
      r = [];
      _ref = this.data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], t = _ref1[0], v = _ref1[1];
        r.push(v);
      }
      return r;
    };

    Timeseries.prototype.filter = function(fn) {
      var r, tv, _i, _len, _ref;
      r = [];
      _ref = this.data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tv = _ref[_i];
        if (fn(tv[0], tv[1])) {
          r.push(tv);
        }
      }
      return $ts(r);
    };

    Timeseries.prototype.timestamps = function() {
      var r, t, v, _i, _len, _ref, _ref1;
      r = [];
      _ref = this.data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], t = _ref1[0], v = _ref1[1];
        r.push(t);
      }
      return r;
    };

    Timeseries.prototype.nearest = function(timestamp) {
      return this.bsearch(timestamp, 0, this.size() - 1);
    };

    Timeseries.prototype.bsearch = function(timestamp, idx1, idx2) {
      var diff1, diff2, mid;
      mid = Math.floor((idx2 - idx1) / 2.0) + idx1;
      if (idx1 === mid) {
        diff1 = Math.abs(this.time(idx1) - timestamp);
        diff2 = Math.abs(this.time(idx2) - timestamp);
        if (diff2 > diff1) {
          return idx1;
        } else {
          return idx2;
        }
      } else if (timestamp < this.time(mid)) {
        return this.bsearch(timestamp, idx1, mid);
      } else if (timestamp > this.time(mid)) {
        return this.bsearch(timestamp, mid, idx2);
      } else {
        return mid;
      }
    };

    Timeseries.prototype.toString = function() {
      return "Timeseries\nitems   : " + (this.size()) + "\ndomain  : " + (this.domain());
    };

    Timeseries.prototype.type = function() {
      return "ts";
    };

    return Timeseries;

  })();

  /*
  # NumbericTimeseries class
  #
  # A class for wrapping timed values
  #
  # data: a 2d array containing
  #
  */


  NumericTimeseries = (function(_super) {

    __extends(NumericTimeseries, _super);

    function NumericTimeseries(data) {
      this.data = data;
      NumericTimeseries.__super__.constructor.call(this, this.data);
    }

    NumericTimeseries.prototype.statistics = function() {
      var max, min, sum, sum2, t, v, _i, _len, _ref, _ref1;
      if (this._stats) {
        return this._stats;
      }
      sum = 0.0;
      sum2 = 0.0;
      min = 999999999999;
      max = -min;
      _ref = this.data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], t = _ref1[0], v = _ref1[1];
        sum += v;
        sum2 += v * v;
        if (v > max) {
          max = v;
        }
        if (v < min) {
          min = v;
        }
      }
      return this._stats = {
        sum: sum,
        min: min,
        max: max,
        sum2: sum2
      };
    };

    NumericTimeseries.prototype.sum = function() {
      return this.statistics().sum;
    };

    NumericTimeseries.prototype.sumsq = function() {
      return this.statistics().sum2;
    };

    NumericTimeseries.prototype.variance = function() {
      var n, r, t, v, _i, _len, _ref, _ref1;
      r = 0;
      _ref = this.data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], t = _ref1[0], v = _ref1[1];
        n = v - this.mean();
        r += n * n;
      }
      return r / (this.size() - 1);
    };

    NumericTimeseries.prototype.stddev = function() {
      return Math.sqrt((this.sumsq() / this.size()) / (this.mean() * this.mean()));
    };

    NumericTimeseries.prototype.mean = function() {
      return this.sum() / this.size();
    };

    NumericTimeseries.prototype.range = function() {
      return [this.min(), this.max()];
    };

    NumericTimeseries.prototype.min = function() {
      return this.statistics().min;
    };

    NumericTimeseries.prototype.max = function() {
      return this.statistics().max;
    };

    NumericTimeseries.prototype.values = function() {
      var r, t, v, _i, _len, _ref, _ref1;
      r = [];
      _ref = this.data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], t = _ref1[0], v = _ref1[1];
        r.push(v);
      }
      return r;
    };

    NumericTimeseries.prototype.norms = function() {
      var r, t, v, _i, _len, _ref, _ref1;
      r = [];
      _ref = this.data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], t = _ref1[0], v = _ref1[1];
        r.push((v - this.mean()) / this.stddev());
      }
      return r;
    };

    NumericTimeseries.prototype.simplify = function(threshold) {
      var last, r, range, tv, _i, _len, _ref;
      if (threshold == null) {
        threshold = 0.1;
      }
      last = this.first();
      range = this.max() - this.min();
      r = [last];
      _ref = this.data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tv = _ref[_i];
        if (((Math.abs(tv[1] - last[1])) / range) > threshold) {
          if (last[0] !== r[r.length - 1][0]) {
            r.push(last);
          }
          r.push(tv);
        }
        last = tv;
      }
      if (last[0] !== r[r.length - 1][0]) {
        r.push(last);
      }
      return new Timeseries(r);
    };

    NumericTimeseries.prototype.match = function(pattern) {
      var best, distance, i, idx, query, source, _i, _ref;
      if (!(pattern instanceof Timeseries)) {
        throw "Must match against a Timeseries object";
      }
      best = 999999999;
      idx = -1;
      query = pattern.norms();
      source = this.norms();
      if (!(query.length <= source.length)) {
        throw "Query length exceeds source length";
      }
      for (i = _i = 0, _ref = source.length - query.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        distance = this.distance(query, source.slice(i, +(i + query.length) + 1 || 9e9));
        if (distance < best) {
          best = distance;
          idx = i;
        }
      }
      return idx;
    };

    NumericTimeseries.prototype.distance = function(ts1, ts2) {
      var idx, sum, v, _i, _len;
      sum = 0.0;
      idx = 0;
      for (_i = 0, _len = ts1.length; _i < _len; _i++) {
        v = ts1[_i];
        sum += (ts2[idx] - v) * (ts2[idx] - v);
        idx++;
      }
      return sum;
    };

    NumericTimeseries.prototype.type = function() {
      return "numeric";
    };

    NumericTimeseries.prototype.plot = function(opts) {
      merge(opts, {
        ts: this
      });
      return new Chart(opts);
    };

    NumericTimeseries.prototype.toString = function() {
      return "Timeseries\nitems   : " + (this.size()) + "\nmean    : " + (this.mean()) + "\nstddev  : " + (this.stddev()) + "\ndomain  : " + (this.domain()) + "\nrange   : " + (this.range()) + "\nvariance: " + (this.variance());
    };

    return NumericTimeseries;

  })(Timeseries);

  /*
  # Multimeseries class
  #
  # A mutli-valued timeseries class which wraps
  # multiple Timeseries objects and provides the same
  # functionality
  #
  */


  MultiTimeseries = (function(_super) {

    __extends(MultiTimeseries, _super);

    function MultiTimeseries(data) {
      var key, point, value, _i, _len, _ref, _ref1, _ref2;
      this.data = data;
      MultiTimeseries.__super__.constructor.call(this, this.data);
      this.lookup = {};
      this.attrs = [];
      _ref = data[0][1];
      for (key in _ref) {
        value = _ref[key];
        this.attrs.push(key);
        this.lookup[key] = [];
      }
      for (_i = 0, _len = data.length; _i < _len; _i++) {
        point = data[_i];
        _ref1 = point[1];
        for (key in _ref1) {
          value = _ref1[key];
          this.lookup[key].push([point[0], value]);
        }
      }
      _ref2 = this.lookup;
      for (key in _ref2) {
        value = _ref2[key];
        this.lookup[key] = $ts(this.lookup[key]);
      }
    }

    MultiTimeseries.prototype.path = function(series) {
      var first, parts;
      parts = series.split("/");
      first = this.series(parts.shift());
      if (first) {
        if (first.type() === "multi") {
          return first.path(parts.join("/"));
        } else {
          return first;
        }
      } else {
        return null;
      }
    };

    MultiTimeseries.prototype.series = function(series) {
      if (!this.lookup[series]) {
        throw "Can't get attribute " + series + " of multi time series";
      }
      return this.lookup[series];
    };

    MultiTimeseries.prototype.dispatch = function(method, series, args) {
      var attr, res, _i, _len, _ref;
      if (series) {
        return this.series(series)[method](args);
      } else {
        res = {};
        _ref = this.attrs;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          attr = _ref[_i];
          res[attr] = this.series(attr)[method](args);
        }
        return res;
      }
    };

    MultiTimeseries.prototype.sum = function(series) {
      return this.dispatch("sum", series);
    };

    MultiTimeseries.prototype.sumsq = function(series) {
      return this.dispatch("sumsq", series);
    };

    MultiTimeseries.prototype.variance = function(series) {
      return this.dispatch("variance", series);
    };

    MultiTimeseries.prototype.stddev = function(series) {
      return this.dispatch("stddev", series);
    };

    MultiTimeseries.prototype.mean = function(series) {
      return this.dispatch("mean", series);
    };

    MultiTimeseries.prototype.range = function(series) {
      return this.dispatch("range", series);
    };

    MultiTimeseries.prototype.min = function(series) {
      return this.dispatch("min", series);
    };

    MultiTimeseries.prototype.max = function(series) {
      return this.dispatch("max", series);
    };

    MultiTimeseries.prototype.values = function(series) {
      return this.dispatch("values", series);
    };

    MultiTimeseries.prototype.norms = function(series) {
      return this.dispatch("norms", series);
    };

    MultiTimeseries.prototype.type = function() {
      return "multi";
    };

    MultiTimeseries.prototype.plot = function() {
      return alert("s");
    };

    return MultiTimeseries;

  })(Timeseries);

  util = {
    timestamp: function(data, start, step) {
      var i, r, v, _i, _len;
      if (start == null) {
        start = new Date().getTime();
      }
      if (step == null) {
        step = 60000;
      }
      i = 0;
      r = [];
      for (_i = 0, _len = data.length; _i < _len; _i++) {
        v = data[_i];
        r.push([start + (i++ * step), v]);
      }
      return r;
    },
    plot: function(opts) {
      if (opts) {
        return console.log("a");
      } else {
        return plotRegistry;
      }
    }
  };

  root.$ts = function(data, mapper, sort) {
    var item, tmp, _i, _len;
    if (mapper == null) {
      mapper = null;
    }
    if (sort == null) {
      sort = false;
    }
    if (data) {
      if (mapper) {
        tmp = [];
        for (_i = 0, _len = data.length; _i < _len; _i++) {
          item = data[_i];
          tmp.push(mapper(item));
        }
        data = tmp;
      }
      if (data.length === 0) {
        throw "$ts expects an array of data.";
      }
      if (data[0].length !== 2) {
        throw "$ts expects input like [[timestamp, value]...]";
      }
      if (typeof data[0][0] !== "number") {
        throw "$ts expects timestamps; eg: [[timestamp, value]...]";
      }
      if (typeof data[0][1] === "number") {
        return new NumericTimeseries(data);
      }
      return new MultiTimeseries(data);
    } else {
      return util;
    }
  };

  SeriesRenderer = (function() {

    SeriesRenderer.prototype.defaults = {
      color: "#ff0000"
    };

    function SeriesRenderer(opts) {}

    SeriesRenderer.prototype.render = function(ts, graph) {
      var point, _i, _len, _ref;
      graph.save();
      graph.beginPath();
      graph.strokeStyle = "#ff0000";
      graph.moveTo(ts.data[0][0], ts.data[0][1]);
      _ref = ts.data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        point = _ref[_i];
        graph.lineTo(point[0], point[1]);
      }
      graph.stroke();
      graph.closePath();
      return graph.restore();
    };

    return SeriesRenderer;

  })();

  LineRenderer = (function() {

    LineRenderer.prototype.defaults = {
      color: "#ff0000"
    };

    function LineRenderer(opts) {}

    LineRenderer.prototype.render = function(ts, graph, scale) {
      var point, _i, _len, _ref;
      graph.save();
      graph.beginPath();
      graph.strokeStyle = "#ff0000";
      graph.moveTo(scale.x(ts.data[0][0]), scale.y(ts.data[0][1]));
      _ref = ts.data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        point = _ref[_i];
        graph.lineTo(scale.x(point[0]), scale.y(point[1]));
      }
      graph.stroke();
      graph.closePath();
      return graph.restore();
    };

    return LineRenderer;

  })();

  renderLine = function(ts, graph, scale, opts) {
    var point, _i, _len, _ref;
    graph.save();
    graph.beginPath();
    graph.strokeStyle = "#ff0000";
    graph.scale(0.000001, 5);
    graph.translate(-ts.data[0][0], 2);
    console.log(ts.data[0]);
    graph.moveTo(ts.data[0][0], ts.data[0][1]);
    _ref = ts.data;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      point = _ref[_i];
      graph.lineTo(point[0], point[1]);
    }
    graph.stroke();
    graph.closePath();
    return graph.restore();
  };

  renderArea = function(ts, graph, scale, opts) {
    var point, yval, _i, _len;
    yval = chart.get("fill", "bot") === "top" ? 0 : chart.height();
    graph.save();
    graph.beginPath();
    graph.fillStyle = chart.get("color");
    graph.moveTo(0, yval);
    for (_i = 0, _len = data.length; _i < _len; _i++) {
      point = data[_i];
      graph.lineTo(scale.x(point[0]), scale.y(point[1]));
    }
    graph.lineTo(chart.width(), yval);
    graph.fill();
    graph.closePath();
    return graph.restore();
  };

  /*
  #
  # Structure
  #
  */


  /*
  Component
  
  Events (hooks)
  
  visit = (chart, x, y) ->
    # when the mouse be moving
  */


  Component = (function() {

    Component.prototype.defaults = {
      name: "component"
    };

    function Component(opts) {
      console.log("s", opts);
      merge(this, this.defaults, opts);
      console.log("s", this);
      this.el = $(this.el);
      this.el.height(this.height() || 100);
    }

    return Component;

  })();

  /*
  Canvas
  
  Base class for all canvas renderables
  
  Events (hooks)
  
  prerender = (chart) ->
    # called before render of canvas
  
  render = (chart) ->
    # called during render (non cached)
  
  postrender = (chart) ->
    # called after render
  
  select = (chart, x, y, idx, point) ->
    # when an item is selected
  
  ----------------
  */


  Chart = (function() {

    Chart.prototype.defaults = {
      name: "component",
      renderers: [new SeriesRenderer(), new LineRenderer()]
    };

    function Chart(opts) {
      merge(this, this.defaults, opts);
      this.el = $(this.el);
      this.build();
      console.log(this);
    }

    Chart.prototype.build = function() {
      if (!this.context) {
        this.canvas = document.createElement("canvas");
        this.el.append(this.canvas);
        if (window.G_vmlCanvasManager) {
          this.canvas = G_vmlCanvasManager.initElement(this.canvas);
        }
        this.context = this.canvas.getContext("2d");
        return this.resize();
      }
    };

    Chart.prototype.invalidate = function() {
      return this._cache = this._scale = null;
    };

    Chart.prototype.resize = function() {
      this.invalidate();
      this.canvas.setAttribute("width", this.width());
      this.canvas.setAttribute("height", this.height());
      return this.render();
    };

    Chart.prototype.render = function() {
      var xs, ys;
      this.context.clearRect(0, 0, this.width(), this.height());
      if (this._cache) {
        return this.context.putImageData(this._cache, 0, 0);
      } else {
        ys = this.height() / (this.ts.max() - this.ts.min());
        xs = this.width() / (this.ts.last()[0] - this.ts.first()[0]);
        this.context.save();
        this.context.scale(xs, -ys);
        this.context.translate(-this.ts.data[0][0], -this.ts.max() + 2);
        this.context.lineWidth = 0.1;
        new SeriesRenderer().render(this.ts, this.context, this.scale());
        this.context.restore();
        if (this.context.getImageData) {
          return this._cache = this.context.getImageData(0, 0, this.width(), this.height());
        }
      }
    };

    Chart.prototype.width = function() {
      return this.el.width();
    };

    Chart.prototype.height = function() {
      return this.el.height();
    };

    Chart.prototype.visit = function(x, y) {};

    Chart.prototype.xscale = function() {
      var w, x1, x2, _ref;
      _ref = this.ts.domain(), x1 = _ref[0], x2 = _ref[1];
      w = this.width();
      return function(time) {
        return ((time - x1) / (x2 - x1)) * w;
      };
    };

    Chart.prototype.yscale = function() {
      var h, y1, y2, _ref;
      _ref = this.ts.range(), y1 = _ref[0], y2 = _ref[1];
      h = this.height();
      return function(v) {
        return h - ((v - y1) / (y2 - y1)) * h;
      };
    };

    Chart.prototype.scale = function() {
      var h, w, xdomain, ydomain;
      if (!this._scale) {
        w = this.width();
        h = this.height();
        xdomain = this.ts.domain();
        ydomain = this.ts.range();
        this._scale = {
          x: this.xscale(),
          y: this.yscale(),
          rx: function(v) {
            return (v / w) * (xdomain[1] - xdomain[0]) + xdomain[0];
          }
        };
      }
      return this._scale;
    };

    return Chart;

  })();

  /*
  
  TimedChart
  
  Base class for time series metrics.  Same as canvas
  except it supports scales.
  */


  VisualSeries = (function(_super) {

    __extends(VisualSeries, _super);

    VisualSeries.prototype.defaults = {
      something: true
    };

    function VisualSeries(opts) {
      var _this = this;
      VisualSeries.__super__.constructor.call(this, opts);
      if (this.get("labels")) {
        this.hook("select", function(chart, x, y, idx, point) {
          return _this.focus(idx);
        });
      }
    }

    VisualSeries.prototype.build = function() {
      var range;
      if (!this.context) {
        VisualSeries.__super__.build.call(this);
        if (this.get("labels")) {
          this.value = $("<label />").addClass("value");
          this.labelEl = $("<div />").addClass("labels");
          this.labelEl.append($("<label />").addClass("name").html(this.get("name")));
          this.labelEl.append(this.value);
          this.el().append(this.labelEl);
        }
        if (this.get("labelRange", false)) {
          range = this.ydomain();
          this.el().append($("<label />").addClass("range low").html(range[0].toFixed(1)));
          return this.el().append($("<label />").addClass("range high").html(range[1].toFixed(1)));
        }
      }
    };

    VisualSeries.prototype.scale = function() {
      var h, w, xdomain, ydomain;
      if (!this._scale) {
        w = this.width();
        h = this.height();
        xdomain = this.xdomain();
        ydomain = this.ydomain();
        this._scale = {
          x: function(v) {
            return ((v - xdomain[0]) / (xdomain[1] - xdomain[0])) * w;
          },
          y: function(v) {
            return h - ((v - ydomain[0]) / (ydomain[1] - ydomain[0])) * h;
          },
          rx: function(v) {
            return (v / w) * (xdomain[1] - xdomain[0]) + xdomain[0];
          }
        };
      }
      return this._scale;
    };

    VisualSeries.prototype.zoom = function(x1, x2) {
      this.zrange = [this.scale().rx(x1), this.scale().rx(x2)];
      this.invalidate();
      return this.render();
    };

    VisualSeries.prototype.unzoom = function() {
      this.zrange = null;
      this.invalidate();
      return this.render();
    };

    VisualSeries.prototype.ydomain = function() {
      var r, r2;
      r = Util.range(this.get("data"), function(p) {
        return p[1];
      });
      r2 = this.get("yrange");
      if (r2) {
        r = [Math.min(r2[0], r[0]), Math.max(r2[1], r[1])];
      }
      return r;
    };

    VisualSeries.prototype.xdomain = function() {
      if (this.zrange) {
        return this.zrange;
      } else if (this.get("timeframe")) {
        return this.get("timeframe");
      } else {
        return Util.range(this.get("data"), function(p) {
          return p[0];
        });
      }
    };

    VisualSeries.prototype.visit = function(x, y) {
      var fn, idx, _i, _len, _ref, _results;
      VisualSeries.__super__.visit.call(this, x, y);
      if (this.gethooks("select").length > 0) {
        idx = Util.nearestIndex(this.get("data"), this.scale().rx(x));
        _ref = this.gethooks("select");
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          fn = _ref[_i];
          _results.push(fn(this, x, y, idx, this.get("data")[idx]));
        }
        return _results;
      }
    };

    VisualSeries.prototype.focus = function(idx) {
      if (this.value) {
        return this.value.html(this.format(this.get("data")[idx]));
      }
    };

    VisualSeries.prototype.format = function(point) {
      if (this.get("format")) {
        return this.get("format")(point);
      } else {
        return point[1].toFixed(1);
      }
    };

    return VisualSeries;

  })(Chart);

  /*
  #
  # Helpers
  #
  */


  plotRegistry = {
    plugins: {},
    renderers: {},
    register: function(type, name, object) {
      switch (type) {
        case "plugin":
          return this.plugins[name] = object;
        case "renderer":
          return this.renderers[name] = object;
        default:
          throw "Unable to register unknown type " + type;
      }
    },
    lookup: function(type, name) {
      switch (type) {
        case "plugin":
          return this.plugins[name];
        case "renderer":
          return this.renderers[name];
        default:
          return null;
      }
    }
  };

  plotRegistry.register("renderer", "line", function(canvas) {
    var data, graph, point, scale, _i, _len;
    data = canvas.ts;
    scale = canvas.scale;
    graph = canvas.context;
    graph.save();
    graph.beginPath();
    graph.strokeStyle = canvas.get("color");
    graph.moveTo(scale.x(data[0][0]), scale.y(data[0][1]));
    for (_i = 0, _len = data.length; _i < _len; _i++) {
      point = data[_i];
      graph.lineTo(scale.x(point[0]), scale.y(point[1]));
    }
    graph.stroke();
    graph.closePath();
    return graph.restore();
  });

}).call(this);
