// Generated by CoffeeScript 1.10.0

/*
ts.js - version 0.9.2

Copyright 2012 Dan Simpson, Mike Countis

MIT License: http://opensource.org/licenses/MIT
 */

(function() {
  var MultiTimeseries, NumericTimeseries, Timeseries, TimeseriesFactory, factory, root,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TimeseriesFactory = (function() {
    function TimeseriesFactory() {}

    TimeseriesFactory.prototype.validate = function(data) {
      if (data.length === 0) {
        throw "Timeseries expects an array of data.";
      }
      if (data[0].length !== 2) {
        throw "Timeseries expects input like [[timestamp, value]...]";
      }
      if (typeof data[0][0] !== "number") {
        throw "Timeseries expects timestamps; eg: [[timestamp, value]...]";
      }
    };

    TimeseriesFactory.prototype.timestamp = function(data, start, step) {
      var i, j, len, r, v;
      if (start == null) {
        start = new Date().getTime();
      }
      if (step == null) {
        step = 60000;
      }
      i = 0;
      r = [];
      for (j = 0, len = data.length; j < len; j++) {
        v = data[j];
        r.push([start + (i++ * step), v]);
      }
      return r;
    };

    TimeseriesFactory.prototype.wrap = function(data, validate) {
      if (validate == null) {
        validate = true;
      }
      if (validate) {
        this.validate(data);
      }
      return new Timeseries(data);
    };

    TimeseriesFactory.prototype.numeric = function(data, validate) {
      if (validate == null) {
        validate = true;
      }
      if (validate) {
        this.validate(data);
        if (typeof data[0][1] !== "number") {
          throw "NumericTimeseries expects timestamps and numbers; eg: [[timestamp, number]...]";
        }
      }
      return new NumericTimeseries(data);
    };

    TimeseriesFactory.prototype.multi = function(data, validate) {
      if (validate == null) {
        validate = true;
      }
      if (validate) {
        this.validate(data);
      }
      return new MultiTimeseries(data);
    };

    TimeseriesFactory.prototype.build = function(data) {
      this.validate(data);
      if (typeof data[0][1] === "number") {
        return this.numeric(data);
      } else if (typeof data[0][1] === "string") {
        return this.wrap(data);
      } else {
        return this.multi(data);
      }
    };

    return TimeseriesFactory;

  })();

  factory = new TimeseriesFactory();


  /*
   *
   *
   */

  Timeseries = (function() {
    function Timeseries(data1) {
      this.data = data1;
      this.squelched = false;
      this.listeners = [];
      this.init_listeners = [];
      this.timeframe = null;
    }

    Timeseries.prototype.size = function() {
      return this.data.length;
    };

    Timeseries.prototype.empty = function() {
      return this.data.length === 0;
    };

    Timeseries.prototype.length = function() {
      return this.data.length;
    };

    Timeseries.prototype.count = function() {
      return this.data.length;
    };

    Timeseries.prototype.slice_indices = function(t1, t2) {
      var idx1, idx2;
      idx1 = this.nearest(t1);
      idx2 = this.nearest(t2);
      if (this.time(idx1) < t1) {
        ++idx1;
      }
      if (this.time(idx2) < t2) {
        ++idx2;
      }
      return [idx1, idx2];
    };

    Timeseries.prototype.limit = function(duration) {
      this.timeframe = duration;
      return this;
    };

    Timeseries.prototype.behead = function() {
      var count, head, min;
      if (this.timeframe === null) {
        return [];
      }
      min = this.end() - this.timeframe;
      count = 0;
      while (this.data[count][0] < min) {
        count++;
      }
      head = this.data.slice(0, count);
      this.data = this.data.slice(count);
      return head;
    };

    Timeseries.prototype.first = function() {
      return this.data[0];
    };

    Timeseries.prototype.last = function() {
      return this.data[this.size() - 1];
    };

    Timeseries.prototype.sample = function(idx) {
      return this.data[idx];
    };

    Timeseries.prototype.time = function(idx) {
      return this.data[idx][0];
    };

    Timeseries.prototype.value = function(idx) {
      return this.data[idx][1];
    };

    Timeseries.prototype.domain = function() {
      return [this.first()[0], this.last()[0]];
    };

    Timeseries.prototype.append = function(t, v) {
      if (this.empty()) {
        this.data.push([t, v]);
        return;
      }
      if (t < this.end()) {
        throw "Can't append sample with past timestamp";
      }
      this.data.push([t, v]);
      this.behead();
      return this.notify();
    };

    Timeseries.prototype.push = function(t, v) {
      return this.append(t, v);
    };

    Timeseries.prototype.add = function(t, v) {
      return this.append(t, v);
    };

    Timeseries.prototype.notify = function() {
      var j, k, len, len1, listener, ref, ref1, results;
      if (this.squelched) {
        return;
      }
      if (this.size() === 2) {
        ref = this.init_listeners;
        for (j = 0, len = ref.length; j < len; j++) {
          listener = ref[j];
          listener();
        }
      }
      ref1 = this.listeners;
      results = [];
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        listener = ref1[k];
        results.push(listener());
      }
      return results;
    };

    Timeseries.prototype.listen = function(fn) {
      return this.listeners.push(fn);
    };

    Timeseries.prototype.on_init = function(fn) {
      return this.init_listeners.push(fn);
    };

    Timeseries.prototype.values = function() {
      var j, len, r, ref, ref1, t, v;
      r = [];
      ref = this.data;
      for (j = 0, len = ref.length; j < len; j++) {
        ref1 = ref[j], t = ref1[0], v = ref1[1];
        r.push(v);
      }
      return r;
    };

    Timeseries.prototype.duration = function() {
      return this.end() - this.start();
    };

    Timeseries.prototype.start = function() {
      return this.first()[0];
    };

    Timeseries.prototype.end = function() {
      return this.last()[0];
    };

    Timeseries.prototype.scan = function(t1, t2) {
      var idx1, idx2, ref;
      ref = this.slice_indices(t1, t2), idx1 = ref[0], idx2 = ref[1];
      return new this.constructor(this.data.slice(idx1, idx2));
    };

    Timeseries.prototype.filter = function(fn) {
      var j, len, r, ref, tv;
      r = [];
      ref = this.data;
      for (j = 0, len = ref.length; j < len; j++) {
        tv = ref[j];
        if (fn(tv[0], tv[1])) {
          r.push(tv);
        }
      }
      return new this.constructor(r);
    };

    Timeseries.prototype.split = function(time) {
      var j, len, r1, r2, ref, tv;
      r1 = [];
      r2 = [];
      ref = this.data;
      for (j = 0, len = ref.length; j < len; j++) {
        tv = ref[j];
        if (tv[0] <= time) {
          r1.push(tv);
        } else {
          r2.push(tv);
        }
      }
      return [new this.constructor(r1), new this.constructor(r2)];
    };

    Timeseries.prototype.partition = function(duration) {
      var chunk, j, len, ref, ref1, result, t, time, v;
      time = this.start() - Math.abs(this.start() % duration);
      result = [];
      chunk = [];
      ref = this.data;
      for (j = 0, len = ref.length; j < len; j++) {
        ref1 = ref[j], t = ref1[0], v = ref1[1];
        while (t - time >= duration) {
          result.push([time, factory.build(chunk)]);
          chunk = [];
          time += duration;
        }
        chunk.push([t, v]);
      }
      if (chunk.length > 0) {
        result.push([time, factory.build(chunk)]);
      }
      return factory.wrap(result, false);
    };

    Timeseries.prototype.map = function(fn) {
      var j, len, r, ref, tv;
      r = [];
      ref = this.data;
      for (j = 0, len = ref.length; j < len; j++) {
        tv = ref[j];
        r.push(fn(tv[0], tv[1]));
      }
      return factory.build(r);
    };

    Timeseries.prototype.pfold = function(duration, fn) {
      return this.partition(duration).map(fn);
    };

    Timeseries.prototype.timestamps = function() {
      var j, len, r, ref, ref1, t, v;
      r = [];
      ref = this.data;
      for (j = 0, len = ref.length; j < len; j++) {
        ref1 = ref[j], t = ref1[0], v = ref1[1];
        r.push(t);
      }
      return r;
    };

    Timeseries.prototype.nearest = function(timestamp, lbound) {
      var idx;
      if (lbound == null) {
        lbound = false;
      }
      if (timestamp <= this.start()) {
        return 0;
      }
      if (timestamp >= this.end()) {
        return this.size() - 1;
      }
      idx = this.bsearch(timestamp, 0, this.size() - 1);
      if (lbound && this.time(idx) > timestamp) {
        idx = Math.max(0, idx - 1);
      }
      return idx;
    };

    Timeseries.prototype.bsearch = function(timestamp, idx1, idx2) {
      var diff1, diff2, mid;
      mid = Math.floor((idx2 - idx1) / 2.0) + idx1;
      if (idx1 === mid) {
        diff1 = Math.abs(this.time(idx1) - timestamp);
        diff2 = Math.abs(this.time(idx2) - timestamp);
        if (diff2 > diff1) {
          return idx1;
        } else {
          return idx2;
        }
      } else if (timestamp < this.time(mid)) {
        return this.bsearch(timestamp, idx1, mid);
      } else if (timestamp > this.time(mid)) {
        return this.bsearch(timestamp, mid, idx2);
      } else {
        return mid;
      }
    };

    Timeseries.prototype.toString = function() {
      return "Timeseries\nitems   : " + (this.size()) + "\ndomain  : " + (this.domain());
    };

    return Timeseries;

  })();


  /*
   * NumbericTimeseries class
   *
   * A class for wrapping timed values
   *
   * data: a 2d array containing
   *
   */

  NumericTimeseries = (function(superClass) {
    extend(NumericTimeseries, superClass);

    function NumericTimeseries(data1) {
      this.data = data1;
      NumericTimeseries.__super__.constructor.call(this, this.data);
    }

    NumericTimeseries.prototype.statistics = function() {
      var j, len, max, min, ref, ref1, sum, t, v;
      if (this._stats) {
        return this._stats;
      }
      sum = 0.0;
      min = Infinity;
      max = -Infinity;
      ref = this.data;
      for (j = 0, len = ref.length; j < len; j++) {
        ref1 = ref[j], t = ref1[0], v = ref1[1];
        sum += v;
        if (v > max) {
          max = v;
        }
        if (v < min) {
          min = v;
        }
      }
      return this._stats = {
        sum: sum,
        min: min,
        max: max
      };
    };

    NumericTimeseries.prototype.behead = function() {
      var head, j, len, ref, t, v;
      head = NumericTimeseries.__super__.behead.call(this);
      if (head.length === 0 || !this._stats) {
        return;
      }
      for (j = 0, len = head.length; j < len; j++) {
        ref = head[j], t = ref[0], v = ref[1];
        this._stats.sum -= v;
        if (v === this._stats.min || v === this._stats.max) {
          this._stats = false;
          return;
        }
      }
    };

    NumericTimeseries.prototype.append = function(t, v) {
      if (t < this.end()) {
        throw "Can't append sample with past timestamp";
      }
      if (this._stats) {
        this._stats.sum += v;
        this._stats.min = Math.min(this._stats.min, v);
        this._stats.max = Math.max(this._stats.max, v);
      }
      return NumericTimeseries.__super__.append.call(this, t, v);
    };

    NumericTimeseries.prototype.sum = function() {
      return this.statistics().sum;
    };

    NumericTimeseries.prototype.sumsq = function() {
      var j, len, m, n, r, ref, ref1, t, v;
      m = this.mean();
      r = 0;
      ref = this.data;
      for (j = 0, len = ref.length; j < len; j++) {
        ref1 = ref[j], t = ref1[0], v = ref1[1];
        n = v - m;
        r += n * n;
      }
      return r;
    };

    NumericTimeseries.prototype.variance = function() {
      return this.sumsq() / (this.size() - 1);
    };

    NumericTimeseries.prototype.stddev = function() {
      return Math.sqrt(this.variance());
    };

    NumericTimeseries.prototype.mean = function() {
      return this.sum() / this.size();
    };

    NumericTimeseries.prototype.range = function() {
      return [this.min(), this.max()];
    };

    NumericTimeseries.prototype.span = function() {
      return this.max() - this.min();
    };

    NumericTimeseries.prototype.min = function() {
      return this.statistics().min;
    };

    NumericTimeseries.prototype.max = function() {
      return this.statistics().max;
    };

    NumericTimeseries.prototype.values = function() {
      var j, len, r, ref, ref1, t, v;
      r = [];
      ref = this.data;
      for (j = 0, len = ref.length; j < len; j++) {
        ref1 = ref[j], t = ref1[0], v = ref1[1];
        r.push(v);
      }
      return r;
    };

    NumericTimeseries.prototype.valuesSorted = function() {
      if (this._valuesSorted) {
        return this._valuesSorted;
      }
      return this._valuesSorted = this.values().sort(function(a, b) {
        return a - b;
      });
    };

    NumericTimeseries.prototype.quartiles = function() {
      return {
        min: this.min(),
        p25: this.p25th(),
        mid: this.median(),
        p75: this.p75th(),
        max: this.max()
      };
    };

    NumericTimeseries.prototype.p25th = function() {
      return this.percentile(0.25);
    };

    NumericTimeseries.prototype.p75th = function() {
      return this.percentile(0.75);
    };

    NumericTimeseries.prototype.median = function() {
      return this.percentile(0.5);
    };

    NumericTimeseries.prototype.percentile = function(p) {
      var idx;
      idx = Math.floor(this.size() * p);
      if (this.size() % 2) {
        return this.valuesSorted()[idx];
      } else {
        return (this.valuesSorted()[idx - 1] + this.valuesSorted()[idx]) / 2;
      }
    };

    NumericTimeseries.prototype.norms = function() {
      var j, len, r, ref, ref1, t, v;
      r = [];
      ref = this.data;
      for (j = 0, len = ref.length; j < len; j++) {
        ref1 = ref[j], t = ref1[0], v = ref1[1];
        r.push((v - this.mean()) / this.stddev());
      }
      return r;
    };

    NumericTimeseries.prototype.simplify = function(threshold) {
      var j, last, len, r, range, ref, tv;
      if (threshold == null) {
        threshold = 0.1;
      }
      last = this.first();
      range = this.max() - this.min();
      r = [last];
      ref = this.data;
      for (j = 0, len = ref.length; j < len; j++) {
        tv = ref[j];
        if (((Math.abs(tv[1] - last[1])) / range) > threshold) {
          if (last[0] !== r[r.length - 1][0]) {
            r.push(last);
          }
          r.push(tv);
        }
        last = tv;
      }
      if (last[0] !== r[r.length - 1][0]) {
        r.push(last);
      }
      return factory.build(r);
    };

    NumericTimeseries.prototype.match = function(pattern) {
      var best, distance, i, idx, j, query, ref, source;
      if (!(pattern instanceof Timeseries)) {
        throw "Must match against a Timeseries object";
      }
      best = 999999999;
      idx = -1;
      query = pattern.norms();
      source = this.norms();
      if (!(query.length <= source.length)) {
        throw "Query length exceeds source length";
      }
      for (i = j = 0, ref = source.length - query.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        distance = this._distance(query, source.slice(i, +(i + query.length) + 1 || 9e9));
        if (distance < best) {
          best = distance;
          idx = i;
        }
      }
      return idx;
    };

    NumericTimeseries.prototype._distance = function(ts1, ts2) {
      var diff, i, j, ref, sum;
      if (ts1.length !== ts2.length) {
        throw "Array lengths must match for distance";
      }
      sum = 0.0;
      for (i = j = 0, ref = ts1.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        diff = ts2[i] - ts1[i];
        sum += diff * diff;
      }
      return Math.sqrt(sum);
    };

    NumericTimeseries.prototype.toString = function() {
      return "Timeseries\nitems   : " + (this.size()) + "\nmean    : " + (this.mean()) + "\nstddev  : " + (this.stddev()) + "\ndomain  : " + (this.domain()) + "\nrange   : " + (this.range()) + "\nvariance: " + (this.variance());
    };

    return NumericTimeseries;

  })(Timeseries);


  /*
  MultiTimeseries class
  
  A wrapper of many timeseries which share a timeline.
  
  The underlying structure ends up being a simple spanning tree, which you can
  query by path or name.
  
  Example... one of your data values looks like this:
  data = [timestamp, {
    dan: {
      drinks: 2,
      calories: 160
    },
    mike: {
      drinks: 1,
      calories: -1
    }
  }, ...]
  
  var tree = $ts.multi(data)
  tree.series("dan/drinks").max(); // -> 2
  tree.series("dan/calories").max(); // -> 160
  tree.series("mike/drinks").max(); // -> 1
  tree.series("mike/calories").max(); // -> -1
  
  tree.series("dan") -> MultiTimeseries
   */

  MultiTimeseries = (function(superClass) {
    extend(MultiTimeseries, superClass);

    function MultiTimeseries(data1) {
      var j, key, len, point, ref, ref1, ref2, value;
      this.data = data1;
      MultiTimeseries.__super__.constructor.call(this, this.data);
      this.lookup = {};
      this.attrs = [];
      ref = this.data;
      for (j = 0, len = ref.length; j < len; j++) {
        point = ref[j];
        ref1 = point[1];
        for (key in ref1) {
          value = ref1[key];
          if (!this.lookup.hasOwnProperty(key)) {
            this.lookup[key] = [];
            this.attrs.push(key);
          }
          this.lookup[key].push([point[0], value]);
        }
      }
      ref2 = this.lookup;
      for (key in ref2) {
        value = ref2[key];
        this.lookup[key] = factory.build(this.lookup[key]);
      }
    }

    MultiTimeseries.prototype.series = function(name) {
      var head, parts;
      if (name[0] === "/") {
        return this.series(name.substr(1));
      }
      if (name.indexOf("/") > 0) {
        parts = name.split("/");
        head = parts.shift();
        if (!this.lookup[head]) {
          return null;
        }
        return this.lookup[head].series(parts.join("/"));
      }
      if (!this.lookup[name]) {
        return null;
      }
      return this.lookup[name];
    };

    MultiTimeseries.prototype.get = function(name) {
      return this.series(name);
    };

    MultiTimeseries.prototype.limit = function(duration) {
      var name, ref, results, ts;
      MultiTimeseries.__super__.limit.call(this, duration);
      ref = this.lookup;
      results = [];
      for (name in ref) {
        ts = ref[name];
        results.push(ts.limit(duration));
      }
      return results;
    };

    MultiTimeseries.prototype.append = function(t, v) {
      var key, value;
      for (key in v) {
        value = v[key];
        if (this.lookup.hasOwnProperty(key)) {
          this.lookup[key].append(t, value);
        } else {
          this.lookup[key] = factory.build([[t, value]]);
          this.attrs.push(key);
        }
      }
      return MultiTimeseries.__super__.append.call(this, t, v);
    };

    MultiTimeseries.prototype.attr = function(name) {
      return this.series(name);
    };

    MultiTimeseries.prototype.serieses = function() {
      return this.attrs;
    };

    MultiTimeseries.prototype.min = function() {
      var key, mins, ref, series;
      mins = [];
      ref = this.lookup;
      for (key in ref) {
        series = ref[key];
        if (series.min) {
          mins.push(series.min());
        }
      }
      return Math.min.apply(Math, mins);
    };

    MultiTimeseries.prototype.max = function() {
      var key, maxes, ref, series;
      maxes = [];
      ref = this.lookup;
      for (key in ref) {
        series = ref[key];
        if (series.max) {
          maxes.push(series.max());
        }
      }
      return Math.max.apply(Math, maxes);
    };

    MultiTimeseries.prototype.exists = function(name) {
      return this.series(name) !== null;
    };

    return MultiTimeseries;

  })(Timeseries);

  root = typeof module !== "undefined" && module.exports ? module.exports : window;

  root.$ts = factory;

}).call(this);
