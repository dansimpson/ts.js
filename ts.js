// Generated by CoffeeScript 1.4.0

/*
Copyright 2012 Dan Simpson
MIT License
*/


(function() {
  var Timeseries, root;

  if (typeof exports !== "undefined" && exports !== null) {
    root = global;
  } else {
    root = window;
  }

  /*
  # Timeseries class
  #
  # A class for wrapping timed values
  #
  # data: a 2d array containing
  #
  */


  Timeseries = (function() {

    function Timeseries(data) {
      this.data = data;
      if (this.data.length === 0) {
        throw "Timeseries requires at least 1 data point";
      }
    }

    Timeseries.prototype.size = function() {
      return this.data.length;
    };

    Timeseries.prototype.sum = function() {
      var r, t, v, _i, _len, _ref, _ref1;
      if (this._sum) {
        return this._sum;
      }
      r = 0.0;
      _ref = this.data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], t = _ref1[0], v = _ref1[1];
        r += v;
      }
      return this._sum = r;
    };

    Timeseries.prototype.sumsq = function() {
      var r, t, v, _i, _len, _ref, _ref1;
      if (this._sum2) {
        return this._sum2;
      }
      r = 0.0;
      _ref = this.data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], t = _ref1[0], v = _ref1[1];
        r += v * v;
      }
      return this._sum2 = r;
    };

    Timeseries.prototype.variance = function() {
      var n, r, t, v, _i, _len, _ref, _ref1;
      r = 0;
      _ref = this.data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], t = _ref1[0], v = _ref1[1];
        n = v - this.mean();
        r += n * n;
      }
      return r / (this.size() - 1);
    };

    Timeseries.prototype.stddev = function() {
      return Math.sqrt((this.sumsq() / this.size()) / (this.mean() * this.mean()));
    };

    Timeseries.prototype.mean = function() {
      return this.sum() / this.size();
    };

    Timeseries.prototype.first = function() {
      return this.data[0];
    };

    Timeseries.prototype.last = function() {
      return this.data[this.size() - 1];
    };

    Timeseries.prototype.sample = function(idx) {
      return this.data[idx];
    };

    Timeseries.prototype.value = function(idx) {
      return this.sample(idx)[1];
    };

    Timeseries.prototype.time = function(idx) {
      return this.sample(idx)[0];
    };

    Timeseries.prototype.domain = function() {
      return [this.first()[0], this.last()[0]];
    };

    Timeseries.prototype.range = function() {
      var max, min, t, v, _i, _len, _ref, _ref1;
      if (this._range) {
        return this._range;
      }
      min = 99999999999;
      max = -min;
      _ref = this.data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], t = _ref1[0], v = _ref1[1];
        if (v > max) {
          max = v;
        }
        if (v < min) {
          min = v;
        }
      }
      return this._range = [min, max];
    };

    Timeseries.prototype.min = function() {
      return this.range()[0];
    };

    Timeseries.prototype.max = function() {
      return this.range()[1];
    };

    Timeseries.prototype.values = function() {
      var r, t, v, _i, _len, _ref, _ref1;
      r = [];
      _ref = this.data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], t = _ref1[0], v = _ref1[1];
        r.push(v);
      }
      return r;
    };

    Timeseries.prototype.map = function(fn) {
      var r, t, v, _i, _len, _ref, _ref1;
      r = [];
      _ref = this.data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], t = _ref1[0], v = _ref1[1];
        r.push(fn(t, v));
      }
      return r;
    };

    Timeseries.prototype.filter = function(fn) {
      var r, tv, _i, _len, _ref;
      r = [];
      _ref = this.data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tv = _ref[_i];
        if (fn(tv[0], tv[1])) {
          r.push(tv);
        }
      }
      return new Timeseries(r);
    };

    Timeseries.prototype.timestamps = function() {
      var r, t, v, _i, _len, _ref, _ref1;
      r = [];
      _ref = this.data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], t = _ref1[0], v = _ref1[1];
        r.push(t);
      }
      return r;
    };

    Timeseries.prototype.norms = function() {
      var r, t, v, _i, _len, _ref, _ref1;
      r = [];
      _ref = this.data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], t = _ref1[0], v = _ref1[1];
        r.push((v - this.mean()) / this.stddev());
      }
      return r;
    };

    Timeseries.prototype.simplify = function(threshold) {
      var last, r, range, tv, _i, _len, _ref;
      if (threshold == null) {
        threshold = 0.1;
      }
      last = this.first();
      range = this.max() - this.min();
      r = [last];
      _ref = this.data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tv = _ref[_i];
        if (((Math.abs(tv[1] - last[1])) / range) > threshold) {
          if (last[0] !== r[r.length - 1][0]) {
            r.push(last);
          }
          r.push(tv);
        }
        last = tv;
      }
      if (last[0] !== r[r.length - 1][0]) {
        r.push(last);
      }
      return new Timeseries(r);
    };

    Timeseries.prototype.match = function(pattern) {
      var best, distance, i, idx, query, source, _i, _ref;
      if (!(pattern instanceof Timeseries)) {
        throw "Must match against a Timeseries object";
      }
      best = 999999999;
      idx = -1;
      query = pattern.norms();
      source = this.norms();
      if (!(query.length <= source.length)) {
        throw "Query length exceeds source length";
      }
      for (i = _i = 0, _ref = source.length - query.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        distance = this.distance(query, source.slice(i, +(i + query.length) + 1 || 9e9));
        if (distance < best) {
          best = distance;
          idx = i;
        }
      }
      return idx;
    };

    Timeseries.prototype.distance = function(ts1, ts2) {
      var idx, sum, v, _i, _len;
      sum = 0.0;
      idx = 0;
      for (_i = 0, _len = ts1.length; _i < _len; _i++) {
        v = ts1[_i];
        sum += (ts2[idx] - v) * (ts2[idx] - v);
        idx++;
      }
      return sum;
    };

    Timeseries.prototype.nearest = function(timestamp) {
      var d1, d2, idx;
      idx = 0;
      while (idx < this.size() && this.data[idx][0] < timestamp) {
        idx++;
      }
      if (idx >= this.size()) {
        idx = this.size() - 1;
      }
      if (idx > 0) {
        d1 = this.data[idx][0] - timestamp;
        d2 = this.data[idx - 1][0] - timestamp;
        if (Math.abs(d1) > Math.abs(d2)) {
          idx -= 1;
        }
      }
      return idx;
    };

    Timeseries.prototype.toString = function() {
      return "Timeseries\nitems   : " + (this.size()) + "\nmean    : " + (this.mean()) + "\nstddev  : " + (this.stddev()) + "\ndomain  : " + (this.domain()) + "\nrange   : " + (this.range()) + "\nvariance: " + (this.variance());
    };

    return Timeseries;

  })();

  root.$ts = function(data, mapFn) {
    if (mapFn == null) {
      mapFn = null;
    }
    if (data) {
      if (mapFn) {
        data = mapFn(data);
      }
      return new Timeseries(data);
    }
    return {
      index: function(data, start, step) {
        var i, r, v, _i, _len;
        if (start == null) {
          start = new Date().getTime();
        }
        if (step == null) {
          step = 60000;
        }
        i = 0;
        r = [];
        for (_i = 0, _len = data.length; _i < _len; _i++) {
          v = data[_i];
          r.push([start + (i++ * step), v]);
        }
        return r;
      },
      sort: function(data) {
        return data.sort();
      },
      SECOND: 1000,
      MINUTE: 1000 * 60,
      HOUR: 1000 * 60 * 60,
      DAY: 1000 * 60 * 60 * 24
    };
  };

}).call(this);
